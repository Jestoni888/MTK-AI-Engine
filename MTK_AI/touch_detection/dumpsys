#!/system/bin/sh

# Immediately detect screen state and run corresponding actions
# One-shot: no loop, no sleep, exits after execution

MOD_DIR="/data/adb/modules/MTK_AI"
SCREEN_OFF_PATH="$MOD_DIR/MTK_AI/AI_MODE/normal_mode/powersave"
EXTERNAL_CFG="/sdcard/MTK_AI_Engine"
NOTIFY_ENABLED_FILE="$MOD_DIR/enable_notifications"

cpu_governor() {
# --- 2. CPU GOVERNOR ---
if [ -f "$EXTERNAL_CFG/manual_governor.txt" ]; then
    GOVERNOR=$(cat "$EXTERNAL_CFG/manual_governor.txt" 2>/dev/null | tr -d '\r\n\t ')
    if [ -n "$GOVERNOR" ]; then
        log "Applying governor: $GOVERNOR"
        for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
            if [ -f "$cpu/cpufreq/scaling_available_governors" ]; then
                if grep -q "$GOVERNOR" "$cpu/cpufreq/scaling_available_governors"; then
                    su -c "echo '$GOVERNOR' > '$cpu/cpufreq/scaling_governor'" 2>/dev/null
                    if [ $? -eq 0 ]; then
                        log "✓ Governor applied to $cpu"
                    else
                        log "✗ Failed to apply governor to $cpu"
                    fi
                else
                    log "Governor '$GOVERNOR' not available for $cpu"
                fi
            fi
        done
    else
        log "Empty governor config"
    fi
else
    log "No governor config found"
fi

LOG_TAG="[RESTORE]"
log() { echo "$LOG_TAG $*"; }

log "Restoring system to normal performance state..."

# 2. Disable low_power mode
settings put global low_power 0
settings put global low_power_sticky 0

# 3. Re-enable app management (disable forced restrictions)
settings put global app_auto_restriction_enabled 0
settings put global forced_app_standby_enabled 0
settings put global app_standby_enabled 0
settings put global forced_app_standby_for_small_battery_enabled 0

# 5. Exit forced Doze
dumpsys deviceidle disable 2>/dev/null
dumpsys deviceidle unforce 2>/dev/null

# 7. Re-enable MIUI AI Preload (if it exists)
if settings get system ai_preload_user_state >/dev/null 2>&1; then
    settings put system ai_preload_user_state 1
fi

BUSYBOX="$MOD_DIR/busybox"
LOCAL_PROP="$MOD_DIR/module.prop"
REMOTE_URL="https://raw.githubusercontent.com/Jestoni888/MTK-AI-Engine/refs/heads/main/MTK_AI/module.prop"
TEMP_FILE="/dev/.mtk_ai_online.prop"

# Initialize variables
LOCAL_VER=0
REMOTE_VER=0
UPDATE_AVAILABLE=false

# Fetch remote module.prop
# We capture the exit code to detect network failures
"$BUSYBOX" wget -q --timeout=10 --tries=1 -O "$TEMP_FILE" "$REMOTE_URL"
WGET_STATUS=$?

if [ $WGET_STATUS -eq 0 ] && [ -f "$TEMP_FILE" ]; then
    # Internet successful and file downloaded
    
    # Extract versionCode from local
    LOCAL_VER=$("$BUSYBOX" awk -F'=' '/^[ \t]*versionCode[ \t]*=/ {gsub(/^[ \t]+|[ \t]+$/, "", $2); print $2; exit}' "$LOCAL_PROP" 2>/dev/null)
    
    # Extract versionCode from remote
    REMOTE_VER=$("$BUSYBOX" awk -F'=' '/^[ \t]*versionCode[ \t]*=/ {gsub(/^[ \t]+|[ \t]+$/, "", $2); print $2; exit}' "$TEMP_FILE" 2>/dev/null)

    # Validate integers
    case "$LOCAL_VER" in ''|*[!0-9]*) LOCAL_VER=0 ;; esac
    case "$REMOTE_VER" in ''|*[!0-9]*) REMOTE_VER=0 ;; esac

    # Compare versions
    if [ "$REMOTE_VER" -gt "$LOCAL_VER" ]; then
        UPDATE_AVAILABLE=true
    fi
    
    # Clean up temp file only if we successfully downloaded it
    rm -f "$TEMP_FILE"
else
    # No internet or download failed -> Force fallback to NO UPDATE
    # Variables remain 0, Update flag remains false
    : # No-op, just ensuring logic flows to the 'else' block below
fi

# Choose description based on the result
if [ "$UPDATE_AVAILABLE" = true ]; then
    NEW_DESC="[NEW UPDATE NOTICE✅ click action button ▶️]-----MediaTek AI Engine has a features in performance, normal use & powersaver in a convenient way"
else
    # This block executes if:
    # 1. No internet (wget failed)
    # 2. Remote version <= Local version
    NEW_DESC="[NO UPDATE❌] MediaTek AI Engine has a features in performance, normal use & powersaver in a convenient way"
fi

# Update ONLY the description line in module.prop
TMP_PROP="$MOD_DIR/module.prop.tmp"

# Ensure we don't overwrite if read fails
if [ ! -f "$LOCAL_PROP" ]; then
    echo "Error: $LOCAL_PROP not found!"
    exit 1
fi

{
    while IFS= read -r line; do
        if echo "$line" | "$BUSYBOX" grep -qE '^[ \t]*description[ \t]*='; then
            echo "description=$NEW_DESC"
        else
            echo "$line"
        fi
    done < "$LOCAL_PROP"
} > "$TMP_PROP"

# Replace original
mv "$TMP_PROP" "$LOCAL_PROP"

# Optional: log
echo "Description updated based on version check (Status: $WGET_STATUS, Local: $LOCAL_VER, Remote: $REMOTE_VER)"
}

# --- NOTIFICATION UTILITY ---
notify_engine() {
    [ ! -f "$NOTIFY_ENABLED_FILE" ] && return 0
    RAW_TEMP=$(cat /sys/class/power_supply/battery/temp 2>/dev/null)
    B_TEMP="$((RAW_TEMP / 10)).$((RAW_TEMP % 10))°C"
    local title="$1"
    local msg="$2"
    su -lp 2000 -c "cmd notification post -S bigtext -t '$title' tag '$msg | temp: $B_TEMP'" >/dev/null 2>&1
}

run_external_binary() {
    SCRIPT_PATH="$1"
    if [ ! -x "$SCRIPT_PATH" ]; then
        return 1
    fi
    "$SCRIPT_PATH" >/dev/null 2>&1 &
}

# Works whether script is root or not
get_screen_state() {
    # Try without su first (if already root)
    local state
    state=$(dumpsys power 2>/dev/null | grep -m1 'mScreenOn=' | cut -d= -f2) && [ -n "$state" ] && {
        echo "$state"
        return
    }

    # Fallback: use su
    state=$(su -c "dumpsys power" 2>/dev/null | grep -m1 'mScreenOn=' | cut -d= -f2) && [ -n "$state" ] && {
        echo "$state"
        return
    }

    # Ultimate fallback: brightness
    local bright
    bright=$(cat /sys/class/leds/lcd-backlight/brightness 2>/dev/null)
    if [ -n "$bright" ] && [ "$bright" -eq 0 ]; then
        echo "false"
    else
        echo "true"
    fi
}

STATE=$(get_screen_state)

if [ "$STATE" = "true" ]; then
    echo "ON"     
        cpu_governor
        settings put global low_power 0
        settings put global low_power_sticky 0
        echo "0" > /proc/sys/kernel/panic
elif [ "$STATE" = "false" ]; then
    echo "OFF"
            if [ -f "$EXTERNAL_CFG/low_power_mode" ]; then       
        run_external_binary "$SCREEN_OFF_PATH"
            fi         
else
    echo "UNKNOWN"
fi
