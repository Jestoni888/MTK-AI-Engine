#!/system/bin/sh
MOD_DIR="/data/adb/modules/MTK_AI"
# --- BUSYBOX INTEGRATION ---
BB="$MOD_DIR/busybox"
[ ! -x "$BB" ] && { echo "FATAL: BusyBox missing"; exit 1; }

# Wrap essential tools
grep() { "$BB" grep "$@"; }; sed() { "$BB" sed "$@"; }; awk() { "$BB" awk "$@"; }
cut() { "$BB" cut "$@"; }; head() { "$BB" head "$@"; }; tail() { "$BB" tail "$@"; }
wc() { "$BB" wc "$@"; }; date() { "$BB" date "$@"; }; ionice() { "$BB" ionice "$@"; }
renice() { "$BB" renice "$@"; }; mkswap() { "$BB" mkswap "$@"; }; swapon() { "$BB" swapon "$@"; }
swapoff() { "$BB" swapoff "$@"; }; free() { "$BB" free "$@"; }

PIDFILE="/data/adb/modules/MTK_AI/logcat.pid"

echo $$ > "$PIDFILE"

# Set highest CPU priority
renice -n -20 -p $$

# Prevent Low Memory Killer (LMK) from targeting this process
if [ -f /proc/$$/oom_score_adj ]; then
    echo -1000 > /proc/$$/oom_score_adj
fi

# Move to top-app cpuset to ensure the script isn't throttled
echo $$ > /dev/cpuset/top-app/tasks 2>/dev/null

# --- CONFIGURATION ---
GAME_LIST_FILE="/sdcard/MTK_AI_Engine/game_list.txt"
WHITELIST_FILE="/sdcard/MTK_AI_Engine/whitelist.txt"
LOG_FILE="/sdcard/MTK_AI_Engine/MTK_AI_Engine.log"
CURRENT_MODE="NONE"

# External Script Paths
EXTERNAL_CFG="/sdcard/MTK_AI_Engine"
SCRIPT_RUNNER="$MOD_DIR/script_runner/global"
DISABLE_THERMAL_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/disable_thermal"
PERFORMANCE_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/performance"
SCREEN_OFF_PATH="$MOD_DIR/MTK_AI/AI_MODE/normal_mode/powersave"
CPUSET_NORMAL_PATH="$MOD_DIR/MTK_AI/AI_MODE/normal_mode/normal_cpuset"
NORMAL_PROP_PATH="$MOD_DIR/MTK_AI/AI_MODE/normal_mode/normal_prop"
BYPASS_OFF_PATH="$MOD_DIR/MTK_AI/AI_MODE/normal_mode/bypass_off"
CHARGER_CHECK_PATH="$MOD_DIR/MTK_AI/AI_MODE/global_mode/charger_check"
GAMING_PROP_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/gaming_prop"
GAMING_PROP2_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/gaming_prop_2"
AUTOFREQ_PATH="$MOD_DIR/MTK_AI/AI_MODE/auto_frequency/auto_frequency"
LIMITER_PATH="$MOD_DIR/MTK_AI/AI_MODE/auto_frequency/cpulimiter"
LITE_GAMING_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/lite_gaming"
UNLOCK_FPS_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/unlockfps"
LIMIT_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/limit"
UNLOCK_PATH="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/unlock"
SF_PATH="$MOD_DIR/MTK_AI/AI_MODE/auto_frequency/surfaceflinger"
RESOURCES_PATH="$MOD_DIR/MTK_AI/AI_MODE/global_mode/resources_tweaks"
WEBVIEW_PATH="$MOD_DIR/MTK_AI/AI_MODE/global_mode/webview_tweaks"
TOUCH="$MOD_DIR/touch_detection/touch2"
MANUAL_GLOBAL_FILE="$MOD_DIR/script_runner/mtk_ai_manual"
NOTIFY_ENABLED_FILE="$EXTERNAL_CFG/enable_notifications"
VOLTAGE_OFFSET="$MOD_DIR/script_runner/mtk_ai_eem_boot"
LIMITER_FILE="$EXTERNAL_CFG/enable_limiter"
APP_OPTIMIZE="$MOD_DIR/MTK_AI/AI_MODE/gaming_mode/app_optimizer"
FREEZE="$MOD_DIR/script_runner/sf_controller"
MONITORX="$EXTERNAL_CFG/enable_monitor"
MONITOR="$MOD_DIR/script_runner/monitor_app_stats"

# --- NOTIFICATION UTILITY ---
notify_engine() {
    # Skip if notification toggle is OFF
    [ ! -f "$NOTIFY_ENABLED_FILE" ] && return 0

    local title="$1"
    local msg="$2"
    local manual_pkg="$3"

    # --- 1. Temperature ---
    RAW_TEMP=$(cat /sys/class/power_supply/battery/temp 2>/dev/null || echo "0")
    B_TEMP="$((RAW_TEMP / 10)).$((RAW_TEMP % 10))¬∞C"

    # --- 2. Governor ---
    GOV_FILE="/sys/devices/system/cpu/cpufreq/policy0/scaling_governor"
    [ ! -f "$GOV_FILE" ] && GOV_FILE="/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor"
    CPU_GOV="Unknown"
    [ -f "$GOV_FILE" ] && CPU_GOV=$(cat "$GOV_FILE" 2>/dev/null | tr -d '[:space:]')

    # --- 3. Power Calculation ---
    VOLT_FILE="/sys/class/power_supply/battery/voltage_now"
    CURR_FILE="/sys/class/power_supply/battery/current_now"
    [ ! -f "$VOLT_FILE" ] && VOLT_FILE="/sys/class/power_supply/bms/voltage_now"
    [ ! -f "$CURR_FILE" ] && CURR_FILE="/sys/class/power_supply/bms/current_now"

    POWER_WATTS="N/A"
    if [ -f "$VOLT_FILE" ] && [ -f "$CURR_FILE" ]; then
        VOLT=$(cat "$VOLT_FILE" 2>/dev/null | tr -d '[:space:]')
        CURR=$(cat "$CURR_FILE" 2>/dev/null | tr -d '[:space:]')
        POWER_WATTS=$(awk -v v="$VOLT" -v c="$CURR" 'BEGIN {
            volts = v / 1000000; amps = c / 1000000
            if (amps < 0) amps = -amps
            val = volts * amps
            if (val >= 0.01 && val <= 60) printf "%.2fW", val; else print "N/A"
        }')
    fi

    # --- 4. Detect Graphics Renderer (Using dumpsys gfxinfo) ---
    RENDERER="üñ•Ô∏è Idle"
    TARGET_APP=""
    CHECK_PKG=""

    # Determine which package to check (Priority: Arg -> Foreground -> Last Game)
    if [ -n "$manual_pkg" ]; then
        CHECK_PKG="$manual_pkg"
    else
        # Try Foreground App
        CHECK_PKG=$(dumpsys window windows 2>/dev/null | grep -E 'mCurrentFocus|mFocusedApp' | grep -oE '[^ /]+/[^ /]+' | head -n 1 | cut -d'/' -f1)
        
        # Fallback to Last Game State
        if [ -z "$CHECK_PKG" ] && [ -f "/dev/.mtk_ai_active_game" ]; then            CHECK_PKG=$(cat /dev/.mtk_ai_active_game 2>/dev/null)
        fi
    fi

    # Run detection if we have a package
    if [ -n "$CHECK_PKG" ]; then
        # ‚úÖ FIX: Check if pidof returns a valid PID (number) instead of using -q
        CHECK_PID=$(pidof -s "$CHECK_PKG" 2>/dev/null)
        
        if [ -n "$CHECK_PID" ]; then
            TARGET_APP="$CHECK_PKG"
            
            # Query gfxinfo and capture output
            # We look for "Pipeline", "Renderer", or "Graphics" lines
            GFX_OUTPUT=$(dumpsys gfxinfo "$CHECK_PKG" 2>/dev/null | grep -E 'Pipeline|Renderer|OpenGL|Vulkan')
            
            if [ -n "$GFX_OUTPUT" ]; then
                # Analyze the output to determine the type
                if echo "$GFX_OUTPUT" | grep -qi "vulkan"; then
                    RENDERER="üéÆ Vulkan"
                elif echo "$GFX_OUTPUT" | grep -qi "gl.*es.*3\|opengl es 3"; then
                    RENDERER="üé® OpenGL ES 3"
                elif echo "$GFX_OUTPUT" | grep -qi "gl.*es.*2\|opengl es 2"; then
                    RENDERER="üñºÔ∏è OpenGL ES 2"
                elif echo "$GFX_OUTPUT" | grep -qi "pipeline"; then
                    # If it mentions Pipeline but not Vulkan, it's likely GL
                    RENDERER="üñ•Ô∏è OpenGL Pipeline"
                else
                    # Fallback if text found but specific version unclear
                    RENDERER="üé® GPU Active"
                fi
            fi
        fi
    fi

    # --- 5. Build Message ---
    local gpu_part=""
    if [ "$RENDERER" != "üñ•Ô∏è Idle" ] && [ -n "$TARGET_APP" ]; then
        gpu_part="| GPU: $RENDERER ($TARGET_APP)"
    elif [ "$RENDERER" != "üñ•Ô∏è Idle" ]; then
        gpu_part="| GPU: $RENDERER"
    fi
    
    local full_msg="$msg | Gov: $CPU_GOV | Pwr: $POWER_WATTS | Temp: $B_TEMP $gpu_part"

    su -lp 2000 -c "cmd notification post -S bigtext -t '$title' tag '$full_msg'" >/dev/null 2>&1
}

log_msg() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
    [ "$(wc -l < $LOG_FILE)" -gt 200 ] &&
        tail -n 200 "$LOG_FILE" > "$LOG_FILE.tmp" &&
        mv "$LOG_FILE.tmp" "$LOG_FILE"
}

run_external_binary() {
    SCRIPT_PATH="$1"
    if [ ! -x "$SCRIPT_PATH" ]; then
        log_msg "‚ùå Binary not executable: $SCRIPT_PATH"
        return 1
    fi

    # Simple: just run it (assume main logic prevents duplicates)
    "$SCRIPT_PATH" >/dev/null 2>&1 &
}

monitor() {
# --- MONITOR MANAGEMENT ---
# Use busybox pkill/pgrep if available to ensure consistency
PGREP="$BB pgrep"
PKILL="$BB pkill"

if [ -f "$MONITORX" ]; then
    # Check if monitor is already running to prevent duplicates
    if ! $PGREP -f "monitor_app_stats" > /dev/null; then
        log_msg "ü§ñ Starting Monitor..."
        # Run in background (&), detach from terminal (nohup/disown equivalent via &)
        sh "$MONITOR" & 
    fi
else
    # Stop monitor if flag file is missing
    if $PGREP -f "monitor_app_stats" > /dev/null; then
        log_msg "‚èπÔ∏è Stopping Monitor..."
        $PKILL -f "monitor_app_stats"
    fi
fi
}

disable_zram() {
echo "Stopping zram..."
# Turn off the swap device
swapoff /dev/block/zram0

# Reset the zram device to free the memory it was holding
echo 1 > /sys/block/zram0/reset

echo "zram disabled. Check stats below:"
free -m
}

enable_zram() {
# Load saved settings
CONF="/data/adb/zram_config/settings.conf"
if [ -f "$CONF" ]; then
    . "$CONF"
else
    # Defaults if no config exists
    SIZE="2048M"
    ALGO="lz4"
    SWAP="100"
fi

# V4 UNIVERSAL ENGINE
ZDEV=$(grep "/zram" /proc/swaps | awk '{print $1}')
[ -z "$ZDEV" ] && ZDEV="/dev/block/zram0"
ZNAME=$(basename "$ZDEV")

swapoff "$ZDEV" 2>/dev/null
echo 1 > "/sys/block/"$ZNAME"/reset"
echo "$ALGO" > "/sys/block/"$ZNAME"/comp_algorithm"
echo "$SIZE" > "/sys/block/"$ZNAME"/disksize"
mkswap "$ZDEV" > /dev/null
swapon -p 100 "$ZDEV" 2>/dev/null || swapon "$ZDEV"

# Apply Swappiness
echo "$SWAP" > /proc/sys/vm/swappiness
}

apply_gaming_logic() {
    local pkg_name="$1"
      
    run_external_binary "$SCRIPT_RUNNER"  
    run_external_binary "$APP_OPTIMIZE" 
    run_external_binary "$FREEZE"  
                            
    if [ -f "$EXTERNAL_CFG/enable_auto_freq" ] && [ -f "$AUTOFREQ_PATH" ]; then
        run_external_binary "$AUTOFREQ_PATH"
    fi
    if [ -f "$EXTERNAL_CFG/enable_performance" ] && [ -f "$PERFORMANCE_PATH" ]; then     
        run_external_binary "$PERFORMANCE_PATH"
    fi
    if [ -f "$EXTERNAL_CFG/enable_gaming_prop" ] && [ -f "$GAMING_PROP_PATH" ]; then
        run_external_binary "$GAMING_PROP_PATH"
    fi        
    if [ -f "$EXTERNAL_CFG/enable_highframerate" ] && [ -f "$UNLOCK_FPS_PATH" ]; then       
        run_external_binary "$UNLOCK_FPS_PATH"
    fi
    if [ -f "$EXTERNAL_CFG/enable_gaming_prop2" ] && [ -f "$GAMING_PROP2_PATH" ]; then
        run_external_binary "$GAMING_PROP2_PATH"
    fi
    if [ -f "$EXTERNAL_CFG/enable_bypass" ] && [ -f "$CHARGER_CHECK_PATH" ]; then
        run_external_binary "$CHARGER_CHECK_PATH"
    fi       
        monitor         
        pkill -f touch2
      
    for c in /sys/devices/system/cpu/cpu*/core_ctl; do echo 0 > "$c/enable"; done
    
    CURRENT_MODE="GAMING"
    log_msg "‚úÖ Gaming Mode: $pkg_name"
    notify_engine "üéÆ Gaming Mode Active" "App: $pkg_name"
}

apply_non_gaming_logic() {
    [ "$CURRENT_MODE" = "NORMAL" ] && return
    log_msg "üîã [MODE] NORMAL: Releasing frequency locks..."
    
    pkill -f charger_check
    pkill -f bypass_on
    echo THAWED > /dev/freezer/frozen/freezer.state
    
    if [ -f "$EXTERNAL_CFG/enable_lite_gaming" ] && [ -f "$LIMIT_PATH" ]; then       
        run_external_binary "$LIMIT_PATH"
    fi
    
    if [ -f "$EXTERNAL_CFG/enable_disable_thermal" ] && [ -f "$DISABLE_THERMAL_PATH" ]; then      
        run_external_binary "$DISABLE_THERMAL_PATH"
    fi
    if [ -f "$EXTERNAL_CFG/enable_performance" ] && [ -f "$PERFORMANCE_PATH" ]; then     
        run_external_binary "$PERFORMANCE_PATH"
    fi   
    if [ -f "$EXTERNAL_CFG/enable_highframerate" ] && [ -f "$UNLOCK_PATH" ]; then       
        run_external_binary "$UNLOCK_PATH"
    fi
    
    # Notify immediately when leaving gaming mode
    notify_engine "üîã Normal Mode" "Optimization Balanced | Cooling Active"

    for policy in /sys/devices/system/cpu/cpufreq/policy*; do
        MIN_VAL=$(cat "$policy/cpuinfo_min_freq")
        MAX_VAL=$(cat "$policy/cpuinfo_max_freq")
        echo "schedutil" > "$policy/scaling_governor"
        echo "$MIN_VAL" > "$policy/scaling_min_freq"
        echo "$MAX_VAL" > "$policy/scaling_max_freq"
    done

    GPU_PATH=$(ls -d /sys/class/devfreq/*mali* 2>/dev/null | head -n 1)
    [ -n "$GPU_PATH" ] && echo "powersave" > "$GPU_PATH/governor"             
    run_external_binary "$SCREEN_ON_PATH"     
    run_external_binary "$WEBVIEW_PATH"    
    run_external_binary "$CPUSET_NORMAL_PATH"
    run_external_binary "$NORMAL_PROP_PATH"
    run_external_binary "$SCRIPT_RUNNER"
    run_external_binary "$RESOURCES_PATH" 
    run_external_binary "$TOUCH"
    run_external_binary "$BYPASS_OFF_PATH"
    run_external_binary "$VOLTAGE_OFFSET"
    run_external_binary "$MANUAL_GLOBAL_FILE"   
    pkill -f lite_gaming
    pkill -f auto_frequency
    monitor
    wm size reset && wm density reset && settings put system accelerometer_rotation 0 && settings put system user_rotation 0
    su -c am broadcast -a com.coloros.phonemanager.action.CLEAN_UP
    su -c "am broadcast -a com.transsion.phonemaster.action.CLEAN_MEMORY"
    CURRENT_MODE="NORMAL"
}

# State tracking file
GAME_STATE_FILE="/dev/.mtk_ai_active_game"
NORMAL_STATE_FILE="/dev/.mtk_ai_normal_mode"
CAMERA_STATE_FILE="/dev/.mtk_ai_camera_active"
CPUSET_STATE_FILE="/dev/.mtk_ai_cpuset_state"

# Config paths (Ensure these are defined in your environment or sourced)
# EXTERNAL_CFG, SCREEN_OFF_PATH, MANUAL_GLOBAL_FILE, WHITELIST_FILE, etc. 
# must be defined before running this script.

LOGCAT_PID_FILE="/data/adb/modules/MTK_AI/logcat_monitor.pid"

# Cleanup old processes
pkill -f "logcat.*events" 2>/dev/null
pkill -f "inotifywait" 2>/dev/null

log_msg() {
    echo "[$(date '+%H:%M:%S')] $1"
    # Optionally log to file: echo "[$(date '+%H:%M:%S')] $1" >> /data/local/tmp/mtk_ai.log
}

# Function to handle the core logic (extracted for reuse)
process_log_line() {
    local line="$1"
    [ -z "$line" ] && return

    # ‚û§ SCREEN OFF TRIGGER
    case "$line" in
        *"screen_off"*|*"sys_screen_off"*|*"screen_toggled=0"*|*"lcd_power: 0"*|*"power_screen_state: [0,"*)
            log_msg "üåô Screen Off Detected."
            run_external_binary "$FREEZE"            
            if [ -f "$EXTERNAL_CFG/low_power_mode" ]; then       
                run_external_binary "$SCREEN_OFF_PATH"                    
            fi         
            notify_engine "üåô Screen Off" "Entering Power Saver Mode"
            ;;
    esac

    # ‚û§ SCREEN ON TRIGGER
    case "$line" in
        *"screen_on"*|*"sys_screen_on"*|*"screen_toggled=1"*|*"lcd_power: 1"*|*"power_screen_state: [1,"*)
            log_msg "‚òÄÔ∏è Screen On Detected."
            echo THAWED > /dev/freezer/frozen/freezer.state    
            run_external_binary "$MANUAL_GLOBAL_FILE"
            notify_engine "‚òÄÔ∏è Screen On" "Restoring Balanced Performance"
            ;;
    esac

    # ‚û§ APP ACTIVITY RESUME ‚Äî GAME OR NORMAL MODE
    case "$line" in        *"input_focus"*|*"wm_on_resume_called"*|*"top_resumed_app_focus"*|*"am_on_resume_called"*|*"monitor_focus_event"*|*"am_resume_activity"*)
            # Extract package name
            DETECTED_PKG=$(echo "$line" | grep -oE '[a-zA-Z0-9._]+\/[a-zA-Z0-9._]+' | cut -d'/' -f1 | tail -n 1)
            if [ -z "$DETECTED_PKG" ]; then
                DETECTED_PKG=$(echo "$line" | sed -n 's/.* \([^/ ]*\)\/[^/ ]*.*/\1/p' | grep -oE '[a-zA-Z0-9._]' | head -n 1)
            fi

            # Skip invalid or system packages
            if [ -z "$DETECTED_PKG" ] || ! echo "$DETECTED_PKG" | grep -q '\.'; then
                return
            fi
        
            # üîí WHITELIST CHECK
            if [ -f "$WHITELIST_FILE" ] && grep -Fxq "$DETECTED_PKG" "$WHITELIST_FILE" 2>/dev/null; then
                log_msg "‚è≠Ô∏è Whitelisted app detected: $DETECTED_PKG - Skipping all processing"
                return
            fi
    
            # üì∏ CAMERA DETECTION
            IS_CAMERA=0
            case "$DETECTED_PKG" in
                *camera*|*Camera*|*snapdragon*|*halo*|*opencamera*|*fovcam*|*mediatek.camera*|\
                com.android.camera|com.sec.android.app.camera|com.google.android.camera|\
                com.huawei.camera|com.oppo.camera|com.vivo.camera|com.oneplus.camera|\
                com.sonyericsson.android.camera|com.motorola.camera|com.zte.camera*)
                    IS_CAMERA=1
                    ;;
            esac
    
            if [ "$IS_CAMERA" = 1 ]; then
                log_msg "üì∏ Camera detected: $DETECTED_PKG"
                if [ -f "$LIMITER_FILE" ] && [ ! -f "${LIMITER_FILE}.exec" ]; then                            
                    mv "$LIMITER_FILE" "${LIMITER_FILE}.exec"
                    log_msg "‚úÖ Limiter disabled for camera (renamed to .exec)"
                fi
                echo "1" > "$CAMERA_STATE_FILE"
                apply_non_gaming_logic
                enable_zram
                rm -f "$GAME_STATE_FILE"
                return
            fi
            
            case "$DETECTED_PKG" in
                *launcher*|*systemui*|*settings*|*google*|*transsion*|android)
                if [ -f "$CAMERA_STATE_FILE" ]; then
                    log_msg "üö™ Exiting camera app"
                    if [ -f "${LIMITER_FILE}.exec" ] && [ ! -f "$LIMITER_FILE" ]; then
                        mv "${LIMITER_FILE}.exec" "$LIMITER_FILE"
                        log_msg "‚úÖ Limiter re-enabled after camera exit"
                    fi                    
                    rm -f "$CAMERA_STATE_FILE"
                fi
                    apply_non_gaming_logic
                    enable_zram
                    rm -f "$GAME_STATE_FILE"
                    return
                    ;;
            esac

            # Check if it's a game
            if [ -f "$GAME_LIST_FILE" ] && grep -Fxq "$DETECTED_PKG" "$GAME_LIST_FILE"; then
                # üéÆ GAME MODE
                if [ -f "$GAME_STATE_FILE" ]; then
                    ACTIVE_GAME=$(cat "$GAME_STATE_FILE" 2>/dev/null)
                    if [ "$ACTIVE_GAME" = "$DETECTED_PKG" ]; then
                        return
                    fi
                fi
               
                echo "$DETECTED_PKG" > "$GAME_STATE_FILE"
                rm -f "$NORMAL_STATE_FILE"
                log_msg "üéÆ Gaming mode triggered for: $DETECTED_PKG"
                notify_engine "üéÆ Gaming mode" "Target: $DETECTED_PKG"
                pkill -f touch2
                
                # üß† APPLY CPUSETS
                CPUSET_RULES="/sdcard/MTK_AI_Engine/gaming_cpuset_rules.json"
                if [ -f "$CPUSET_RULES" ]; then
                    CURRENT_STATE="$DETECTED_PKG:$(md5sum "$CPUSET_RULES" 2>/dev/null | cut -d' ' -f1)"
                    LAST_STATE=$(cat "$CPUSET_STATE_FILE" 2>/dev/null)
    
                    if [ "$CURRENT_STATE" != "$LAST_STATE" ]; then
                        log_msg "üß† Applying cpusets (jq-free)..."
                        echo "0-7" > /dev/cpuset/top-app/cpus 2>/dev/null

                        QUOTED=$(grep -o '"[^"]*"' "$CPUSET_RULES" 2>/dev/null | tr -d '"')
                        set -- $QUOTED

                        while [ $# -ge 2 ]; do
                            pkg="$1"
                            cpuset="$2"
                            shift 2

                            case "$cpuset" in
                                background|system-background|top-app) ;;
                                *) continue ;;
                            esac

                            case "$pkg" in
                                android|com.android.systemui|com.android.phone|com.android.shell|com.topjohnwu.magisk|io.github.kernelsu.manager|logcat|dumpsys2|sh)                                    continue
                                    ;;
                            esac

                            if [ "$pkg" = "$DETECTED_PKG" ]; then
                                continue
                            fi

                            for pid in $(pidof "$pkg" 2>/dev/null); do
                                if [ -n "$pid" ] && [ -w "/dev/cpuset/$cpuset/cgroup.procs" ]; then
                                    echo "$pid" > "/dev/cpuset/$cpuset/cgroup.procs" 2>/dev/null
                                    log_msg "‚Üí $pkg ($pid) ‚Üí $cpuset"
                                fi
                            done
                        done

                        echo "$CURRENT_STATE" > "$CPUSET_STATE_FILE"
                        log_msg "‚úÖ Cpuset assignment completed!"
                    else
                        log_msg "‚ÑπÔ∏è Cpusets already applied ‚Äî skipping"
                    fi
                fi
                
                # üçÉ LITE GAMING
                if [ -f "$EXTERNAL_CFG/enable_lite_gaming" ] && [ -f "$LITE_GAMING_PATH" ]; then
                    log_msg "üçÉ Lite Gaming triggered for: $DETECTED_PKG"
                    run_external_binary "$LITE_GAMING_PATH"
                    notify_engine "üçÉ Lite Gaming Mode" "Target: $DETECTED_PKG"
                fi
                
                # üéØ PER-APP AUTO-TUNING TRIGGER
                PER_APP_DIR="/sdcard/MTK_AI_Engine/per_app"
                VSYNC_DIR="/sdcard/MTK_AI_Engine/vsync_configs"
                REFRESH_LOCK_DIR="/sdcard/MTK_AI_Engine/refresh_locks"
                RENDERER_DIR="/sdcard/MTK_AI_Engine/threading_configs"
                PKG="$DETECTED_PKG"
                : ${BASE_DENSITY:=480}

                # --- 1. RESOLUTION SCALING ---
                SCALE_FILE="$PER_APP_DIR/${PKG}.scale"
                if [ -f "$SCALE_FILE" ]; then
                    SCALE_PCT=$(tr -d '\r\n\t ' < "$SCALE_FILE")
                    if [ -n "$SCALE_PCT" ] && [ "$SCALE_PCT" -eq "$SCALE_PCT" ] 2>/dev/null; then
                        NEW_DENSITY=$(( (BASE_DENSITY * SCALE_PCT) / 100 ))
                        wm density "$NEW_DENSITY" 2>/dev/null && log_msg "üì± Scaling: ${SCALE_PCT}% ‚Üí $PKG"
                    fi
                fi

                # --- 2. CPU GOVERNOR ---
                GOV_FILE="$PER_APP_DIR/${PKG}.governor"                
                if [ -f "$GOV_FILE" ]; then
                    GOVERNOR=$(tr -d '\r\n\t ' < "$GOV_FILE")
                    if [ -n "$GOVERNOR" ]; then
                        for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
                            gov_path="$cpu/cpufreq/scaling_governor"
                            [ -w "$gov_path" ] && echo "$GOVERNOR" > "$gov_path" 2>/dev/null
                        done
                        log_msg "‚ö° Governor: $GOVERNOR ‚Üí $PKG"
                    fi
                fi

                # --- 3. RENDERER ---
                RENDERER_FILE="$RENDERER_DIR/${PKG}.conf"
                if [ -f "$RENDERER_FILE" ]; then
                    RENDERER=$(tr -d '\r\n\t ' < "$RENDERER_FILE")
                    case "$RENDERER" in
                        skiavk|skiagl)
                            setprop debug.hwui.renderer "$RENDERER" 2>/dev/null
                            log_msg "üé® Renderer: $RENDERER ‚Üí $PKG"
                            ;;
                    esac
                fi

                # --- 4. VSYNC ---
                VSYNC_FILE="$VSYNC_DIR/${PKG}.vsync"
                if [ -f "$VSYNC_FILE" ]; then
                    VSYNC_NS=$(tr -d '\r\n\t ' < "$VSYNC_FILE")
                    if [ -n "$VSYNC_NS" ] && [ "$VSYNC_NS" -eq "$VSYNC_NS" ] 2>/dev/null; then
                        setprop debug.sf.early_phase_offset_ns "$VSYNC_NS"
                        setprop debug.sf.early_gl_phase_offset_ns "$VSYNC_NS"
                        setprop debug.sf.high_fps_early_phase_offset_ns "$VSYNC_NS"
                        setprop debug.sf.high_fps_early_gl_phase_offset_ns "$VSYNC_NS"
                        setprop debug.sf.high_fps_late_app_phase_offset_ns "$VSYNC_NS"
                        log_msg "‚è±Ô∏è VSync: ${VSYNC_NS}ns ‚Üí $PKG"
                    fi
                fi

                # --- 5. REFRESH RATE ---
                REFRESH_FILE="$REFRESH_LOCK_DIR/${PKG}.mode"
                if [ -f "$REFRESH_FILE" ]; then
                    MODE_ID=$(tr -d '\r\n\t ' < "$REFRESH_FILE")
                    if [ -n "$MODE_ID" ] && [ "$MODE_ID" -eq "$MODE_ID" ] 2>/dev/null; then
                        service call SurfaceFlinger 1035 i32 "$MODE_ID" >/dev/null 2>&1 && log_msg "üñ•Ô∏è Refresh Rate: mode $MODE_ID ‚Üí $PKG"
                    fi
                fi
    
                # --- 6. EEM VOLTAGE OFFSET ---
                EEM_FILE="$PER_APP_DIR/${PKG}.eem_offset"
                if [ -f "$EEM_FILE" ]; then
                    EEM_OFFSET=$(tr -d '\r\n\t ' < "$EEM_FILE")  
                                      if [ -n "$EEM_OFFSET" ] && [ "$EEM_OFFSET" -eq "$EEM_OFFSET" ] 2>/dev/null; then
                        for eem_path in \
                            /proc/eem/EEM_DET_B/eem_offset \
                            /proc/eem/EEM_DET_L/eem_offset \
                            /proc/eem/EEM_DET_CCI/eem_offset \
                            /proc/eem/EEM_DET_BL/eem_offset \
                            /proc/eemg/EEMG_DET_GPU/eemg_offset \
                            /proc/eemg/EEMG_DET_GPU_HI/eemg_offset; do
                             if [ -f "$eem_path" ]; then
                                echo "$EEM_OFFSET" > "$eem_path" 2>/dev/null && log_msg "‚ö° EEM Offset: ${EEM_OFFSET} ‚Üí $PKG"
                             fi
                        done
                    fi
                fi
                
                             # --- 7. CPU FREQUENCY PERCENT ---
                CPU_PERCENT_FILE="$PER_APP_DIR/${PKG}.cpu_percent"
                if [ -f "$CPU_PERCENT_FILE" ]; then
                    CPU_PCT=$(tr -d '\r\n\t ' < "$CPU_PERCENT_FILE")
                    if [ -n "$CPU_PCT" ] && [ "$CPU_PCT" -eq "$CPU_PCT" ] 2>/dev/null; then
                        # Clamp to safe range 50-100
                        CPU_PCT=$(( CPU_PCT < 50 ? 50 : (CPU_PCT > 100 ? 100 : CPU_PCT) ))
                        
                        # Apply to ALL CPUs using your shell logic
                        for cpu in /sys/devices/system/cpu/cpu[0-9]*; do
                            if [ -f "$cpu/cpufreq/cpuinfo_max_freq" ]; then
                                MAX_FREQ=$(cat "$cpu/cpufreq/cpuinfo_max_freq")
                                MIN_FREQ=$(cat "$cpu/cpufreq/cpuinfo_min_freq")
                                TARGET_MAX=$((MAX_FREQ * CPU_PCT / 100))
                                echo "$MIN_FREQ" > "$cpu/cpufreq/scaling_min_freq" 2>/dev/null
                                echo "$TARGET_MAX" > "$cpu/cpufreq/scaling_max_freq" 2>/dev/null
                            fi
                        done
                        log_msg "‚ö° CPU Max: ${CPU_PCT}% ‚Üí $PKG"
                    fi
                fi         
                
                    # --- 8. RESOLUTION CHANGER ---
                RES_FILE="$PER_APP_DIR/${PKG}.resolution"
                if [ -f "$RES_FILE" ]; then
                    RES_VALUE=$(tr -d '\r\n\t ' < "$RES_FILE")
                    # Validate format (must contain 'x', e.g., 720x1280)
                    if [ -n "$RES_VALUE" ] && echo "$RES_VALUE" | grep -qE '^[0-9]+x[0-9]+$'; then
                        # Apply resolution
                        wm size "$RES_VALUE" 2>/dev/null && log_msg "üì± Resolution: $RES_VALUE ‚Üí $PKG"
                        
                        # Optional: Reset density to default to prevent UI scaling issues
                        # Uncomment next line if you want density to reset automatically
                        # wm density reset 2>/dev/null
                    else
                        # If value is 'native', reset resolution
                        if [ "$RES_VALUE" = "native" ]; then
                            wm size reset 2>/dev/null && log_msg "üì± Resolution: Reset to Native ‚Üí $PKG"
                            wm density reset 2>/dev/null
                        fi
                    fi
                fi          
                
                  # --- 9. CUSTOM SHELL COMMAND (Base64 Decoded) ---
                CMD_FILE="$PER_APP_DIR/${PKG}.cmd"
                if [ -f "$CMD_FILE" ]; then
                    # Read the Base64 string
                    ENCODED_CMD=$(cat "$CMD_FILE" 2>/dev/null | tr -d '\r\n\t ')
                    
                    if [ -n "$ENCODED_CMD" ]; then
                        log_msg "üìú Executing custom command for $PKG..."
                        
                        # ‚úÖ Decode Base64 then Execute
                        # We use 'echo ... | base64 -d' to get the original command
                        DECODED_CMD=$(echo "$ENCODED_CMD" | base64 -d 2>/dev/null)
                        
                        if [ -n "$DECODED_CMD" ]; then
                            # Execute the decoded command
                            eval "$DECODED_CMD" 2>/dev/null
                            log_msg "‚úÖ Custom command execution completed for $PKG"
                        else
                            log_msg "‚ö†Ô∏è Failed to decode command for $PKG"
                        fi
                    fi
                fi
                
                # --- ‚ö° FAST WHITELIST THROTTLING ---
GAME_PID=$(pidof "$DETECTED_PKG" | awk '{print $1}')
T_FILE="/sdcard/MTK_AI_Engine/whitelist.txt"

if [ -n "$GAME_PID" ] && [ -f "$T_FILE" ]; then
    log_msg "üõ°Ô∏è Throttling Whitelisted Apps for $DETECTED_PKG..."

    # 1. Boost Game Immediately (Real-Time)
    ionice -c 1 -n 0 -p $GAME_PID 2>/dev/null
    chrt -f 99 -p $GAME_PID 2>/dev/null

    # 2. Read Whitelist & Throttle Only Listed Apps
    # This loop runs only ~30 times (your list size) instead of 500+ (all PIDs)
    while IFS= read -r pkg || [ -n "$pkg" ]; do
        # Skip empty lines or comments
        [ -z "$pkg" ] && continue
        [[ "$pkg" == \#* ]] && continue

        # Find PIDs for this package
        APP_PIDS=$(pidof "$pkg")
        
        if [ -n "$APP_PIDS" ]; then
            for pid in $APP_PIDS; do
                # Set I/O to IDLE (Class 3) - They wait until Game is done
                ionice -c 3 -p $pid 2>/dev/null
                # Set CPU Priority to Lowest (Nice 19)
                renice -n 19 -p $pid 2>/dev/null
            done
            # Optional: Log only if you want verbose output (comment out for max speed)
             log_msg "‚¨áÔ∏è Throttled: $pkg"
        fi
    done < "$T_FILE"

    log_msg "‚úÖ Whitelist Throttling Complete (Instant)"
fi
                      
                if [ -f "$EXTERNAL_CFG/disable_zram" ]; then 
                    disable_zram
                else
                    enable_zram
                fi
                    apply_gaming_logic "$DETECTED_PKG"
            else
                # üîã NORMAL MODE
                if [ -f "$CAMERA_STATE_FILE" ]; then
                    log_msg "üö™ Exiting camera app"
                    if [ -f "${LIMITER_FILE}.exec" ] && [ ! -f "$LIMITER_FILE" ]; then
                        mv "${LIMITER_FILE}.exec" "$LIMITER_FILE"
                        log_msg "‚úÖ Limiter re-enabled after camera exit"
                    fi
                    rm -f "$CAMERA_STATE_FILE"
                fi
                    enable_zram
                    apply_non_gaming_logic
                    rm -f "$GAME_STATE_FILE"
                    echo "1" > "$NORMAL_STATE_FILE"
            fi
            ;;
    esac
}

# Define the monitor function IN THE MAIN SCOPE
start_logcat_monitor() {
    log_msg "üöÄ Starting direct logcat stream processor..."
    
    while true; do
        # FIX: Use standard pipe '|' instead of process substitution '< <()'
        # This works on mksh, sh, and bash on all Android versions
        logcat -b events -T 1 -v threadtime | while IFS= read -r line; do
            process_log_line "$line"
        done
        
        # If logcat dies or the pipe breaks, restart after delay
        log_msg "‚ö†Ô∏è Logcat stream disconnected. Restarting in 2s..."
        sleep 2
    done
}

# Kill any existing monitor first to prevent duplicates
if [ -f "$LOGCAT_PID_FILE" ]; then
    OLD_PID=$(cat "$LOGCAT_PID_FILE")
    kill "$OLD_PID" 2>/dev/null
fi

# Start the monitor in the background
start_logcat_monitor &
MONITOR_PID=$!
echo "$MONITOR_PID" > "$LOGCAT_PID_FILE"

log_msg "‚úÖ Monitor started with PID: $MONITOR_PID"

# Optional: Clean up on script exit
trap "kill $MONITOR_PID 2>/dev/null; rm -f $LOGCAT_PID_FILE" EXIT INT TERM

LOGCAT_PID=$!
echo $LOGCAT_PID > "$LOGCAT_PID_FILE"

# Optional: Use inotifywait to monitor State Files for external changes
# This replaces the need to poll these files inside the main loop if other scripts modify them
if command -v inotifywait >/dev/null 2>&1; then
    (
        log_msg "üëÅÔ∏è Starting inotify watcher for state files..."
        while true; do
            # Watch for modifications to state files
            inotifywait -q -e modify "$GAME_STATE_FILE" "$NORMAL_STATE_FILE" "$CAMERA_STATE_FILE" "$CPUSET_STATE_FILE" 2>/dev/null
            
            # Trigger a dummy event or re-check logic if needed
            # For this script, the main logic is driven by logcat, but this ensures 
            # the script wakes up immediately if an external tool tweaks these flags
            log_msg "üîÑ State file modification detected via inotify"
            
            # Example: Force refresh cpusets if CPUSET_STATE_FILE was touched externally
            if [ -f "$CPUSET_STATE_FILE" ]; then
                 # Add custom logic here if external tools modify state files
                 :
            fi
        done
    ) &
else
    log_msg "‚ö†Ô∏è inotifywait not found. Running in fallback mode (Logcat stream only)."
fi

# Main Keep-Alive Loop (No sleep polling for logs anymore)
# This loop just ensures the background logcat processor stays alive
while true; do
    if [ -f "$LOGCAT_PID_FILE" ]; then
        CUR_PID=$(cat "$LOGCAT_PID_FILE")
        if ! kill -0 "$CUR_PID" 2>/dev/null; then
            log_msg "üîÑ Logcat processor died, restarting..."
            pkill -f "logcat.*events" 2>/dev/null
            # The subshell above has 'exec $0' to restart itself, but we can also respawn here
            # For simplicity, we rely on the subshell's self-restart or let the watchdog handle it
        fi
    fi
    sleep 5 # Long sleep just for watchdog, not for event detection
done
