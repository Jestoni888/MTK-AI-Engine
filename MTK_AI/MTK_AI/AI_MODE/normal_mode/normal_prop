#!/system/bin/sh
#!/data/adb/modules/MTK_AI/busybox sh

LOG_FILE="/sdcard/MTK_AI_Engine/MTK_AI_Engine.log"

log_msg() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

echo "0" > /proc/sys/kernel/panic
    
# 1. Apply Properties (Fast)
setprop debug.hwui.render_ahead 0
setprop persist.sys.miravision.vivid.mode 0
setprop persist.sys.force_vivid 0
setprop persist.sys.framepredict.enable false
setprop debug.sf.latch_unsignaled false
setprop debug.cpurendering false
setprop debug.egl.force_msaa false
setprop persist.sys.ui.hw true
setprop persist.sys.use_dithering 0
setprop debug.sf.early_phase_offset_ns 0
setprop debug.sf.early_gl_phase_offset_ns 0
setprop debug.sf.high_fps_early_phase_offset_ns 0
setprop debug.sf.high_fps_early_gl_phase_offset_ns 0

service call SurfaceFlinger 1008 i32 0 >/dev/null 2>&1
        
    log_msg "ðŸŸ¢ NORMAL MODE PROPS applied"
 
# --- Configuration ---
LOG_FILE="/sdcard/MTK_AI_Engine/MTK_AI_Engine.log"
PPM_PATH="/proc/ppm/policy_status"

# Ensure the script is executed with root privileges
if [[ $EUID -ne 0 ]]; then
   echo "This script requires root privileges. Please run with 'su -c ./set_ppm_policies.sh' or use 'su' before execution."
   exit 1
fi

# --- Logging Function ---
# Logs a timestamped message to the LOG_FILE
log_action() {
    local message="$1"
    # Get current timestamp
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    echo "[$timestamp] $message" >> "$LOG_FILE"
}

# --- Initialization and Root Check ---
# Log script start
log_action "=================================================="
log_action "Script execution started."

# Ensure the script is executed with root privileges
if [[ $EUID -ne 0 ]]; then
   local error_msg="This script requires root privileges. Please run with 'su -c ./set_ppm_policies.sh' or use 'su' before execution."
   echo "$error_msg"
   log_action "ERROR: $error_msg" # Log the error
   log_action "Script execution failed (Missing root)."
   exit 1
fi

log_action "Root privileges confirmed. Proceeding with PPM settings."


# --- Current Status Check ---
echo "--- Current PPM Policy Status ---"
# Check if PPM_PATH exists before trying to read it
if [ -f "$PPM_PATH" ]; then
    current_status=$(cat "$PPM_PATH")
    echo "$current_status"
    log_action "Current PPM Policy Status:\n$current_status"
else
    local warning_msg="WARNING: PPM_PATH ($PPM_PATH) not found."
    echo "$warning_msg"
    log_action "$warning_msg"
fi
echo "---------------------------------"


# --- Policy Definitions ---
# Define the policies and their desired status (1=enabled, 0=disabled)
declare -A policies
policies[9]=1  # PPM_POLICY_SYS_BOOST: enabled (As requested)

log_action "Defined target policies: ${!policies[@]} to ${policies[@]}"

echo "Applying new PPM Policy settings..."
log_action "Starting to apply policies."


# --- Policy Application Loop ---
# Loop through the policies and apply the status
for idx in "${!policies[@]}"; do
    status=${policies[$idx]}
    
    # Write the index and status (1 or 0) to the policy_status file
    echo "$idx $status" > "$PPM_PATH" 2>/dev/null
    
    # Check if the operation was successful (policies may not exist on all kernels)
    if [ $? -eq 0 ]; then
        local success_msg="Policy [$idx] set to $status."
        echo "$success_msg"
        log_action "$success_msg"
    else
        local warning_msg="Warning: Could not set policy [$idx] to $status (File write failed or policy unavailable)."
        echo "$warning_msg"
        log_action "$warning_msg"
    fi
done

echo "---------------------------------"


# --- New Status Check ---
echo "--- New PPM Policy Status ---"
if [ -f "$PPM_PATH" ]; then
    new_status=$(cat "$PPM_PATH")
    echo "$new_status"
    log_action "New PPM Policy Status after applying settings:\n$new_status"
else
    # The warning for path not found was logged earlier, just echo the message again.
    echo "WARNING: PPM_PATH ($PPM_PATH) not found. Cannot check new status."
fi
echo "---------------------------"

echo "Script execution complete. Check $LOG_FILE for details."
log_action "Script execution complete."

log -t "NetTweak" "Starting network tweaks..."

# === Universal Kernel Tweaks ===
if [ -f /proc/sys/net/ipv4/tcp_congestion_control ]; then
  echo bbr > /proc/sys/net/ipv4/tcp_congestion_control 2>/dev/null || \
  echo cubic > /proc/sys/net/ipv4/tcp_congestion_control 2>/dev/null
  log -t "NetTweak" "TCP congestion control set"
fi

if [ -f /proc/sys/net/ipv4/tcp_window_scaling ]; then
  echo 1 > /proc/sys/net/ipv4/tcp_window_scaling
fi

if [ -f /proc/sys/net/ipv4/tcp_low_latency ]; then
  echo 1 > /proc/sys/net/ipv4/tcp_low_latency
fi

# === Platform Detection & Runtime Props ===
PLATFORM=$(getprop ro.board.platform)
BASEBAND=$(getprop ro.baseband)

# --- MediaTek ---
if echo "$PLATFORM" | grep -qiE "mt[0-9]+|mt6[0-9]+"; then
  log -t "NetTweak" "Detected MediaTek. Applying MTK runtime tweaks."
  setprop persist.radio.mtksms 1
  setprop persist.meta.dumpdata 0
  setprop persist.radio.custom.ecc 1

# --- Qualcomm ---
elif echo "$PLATFORM" | grep -qiE "msm[0-9]+|sdm[0-9]+|sm[0-9]+|kona|lito|lahaina"; then
  log -t "NetTweak" "Detected Qualcomm. Applying QMI runtime tweaks."
  setprop persist.data.netmgrd.qos.enable true
  setprop persist.data.mode concurrent
  setprop persist.rmnet.data.enable true
  setprop persist.data.iwlan.enable true

# --- Samsung/Exynos ---
elif echo "$BASEBAND" | grep -qiE "exynos"; then
  log -t "NetTweak" "Detected Exynos. Applying Samsung runtime tweaks."
  setprop persist.data.mode concurrent

# --- Universal Fallback ---
else
  log -t "NetTweak" "Unknown Platform. Applying universal runtime tweaks."
fi

# === Interface Route Tweaks ===
sleep 5
for iface in rmnet0 rmnet_data0 pdp0 ccmni0; do
  if ip link show $iface >/dev/null 2>&1; then
    log -t "NetTweak" "Applying route tweaks to $iface"
    ip route change default dev $iface initcwnd 30 initrwnd 30 2>/dev/null
    break
  fi
done

# === Flush DNS Cache ===
ndc resolver flushdefaultif 2>/dev/null
ndc resolver flushif 2>/dev/null

log -t "NetTweak" "Network Tweaks Applied Successfully."
